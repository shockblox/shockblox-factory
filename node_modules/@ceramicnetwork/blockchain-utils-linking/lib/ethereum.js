"use strict";
var __createBinding = (this && this.__createBinding) || (Object.create ? (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    Object.defineProperty(o, k2, { enumerable: true, get: function() { return m[k]; } });
}) : (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    o[k2] = m[k];
}));
var __setModuleDefault = (this && this.__setModuleDefault) || (Object.create ? (function(o, v) {
    Object.defineProperty(o, "default", { enumerable: true, value: v });
}) : function(o, v) {
    o["default"] = v;
});
var __importStar = (this && this.__importStar) || function (mod) {
    if (mod && mod.__esModule) return mod;
    var result = {};
    if (mod != null) for (var k in mod) if (k !== "default" && Object.prototype.hasOwnProperty.call(mod, k)) __createBinding(result, mod, k);
    __setModuleDefault(result, mod);
    return result;
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.authenticate = exports.createLink = exports.normalizeAccountId = exports.isERC1271 = exports.isEthAddress = exports.EthereumAuthProvider = void 0;
const caip_1 = require("caip");
const util_1 = require("./util");
const uint8arrays = __importStar(require("uint8arrays"));
const sha256 = __importStar(require("@stablelib/sha256"));
const ADDRESS_TYPES = {
    ethereumEOA: 'ethereum-eoa',
    erc1271: 'erc1271',
};
const CHAIN_NAMESPACE = 'eip155';
class EthereumAuthProvider {
    constructor(provider, address, opts = {}) {
        this.provider = provider;
        this.address = address;
        this.opts = opts;
        this.isAuthProvider = true;
    }
    async accountId() {
        const payload = util_1.encodeRpcMessage('eth_chainId', []);
        const chainIdHex = await safeSend(payload, this.provider);
        const chainId = parseInt(chainIdHex, 16);
        return new caip_1.AccountID({
            address: this.address,
            chainId: `${CHAIN_NAMESPACE}:${chainId}`,
        });
    }
    async authenticate(message) {
        const accountId = await this.accountId();
        return authenticate(message, accountId, this.provider);
    }
    async createLink(did) {
        const accountId = await this.accountId();
        return createLink(did, accountId, this.provider, this.opts);
    }
    withAddress(address) {
        return new EthereumAuthProvider(this.provider, address);
    }
}
exports.EthereumAuthProvider = EthereumAuthProvider;
function isEthAddress(address) {
    return /^0x[a-fA-F0-9]{40}$/.test(address);
}
exports.isEthAddress = isEthAddress;
async function getCode(address, provider) {
    const payload = util_1.encodeRpcMessage('eth_getCode', [address, 'latest']);
    return safeSend(payload, provider);
}
async function safeSend(data, provider) {
    const send = (provider.sendAsync ? provider.sendAsync : provider.send).bind(provider);
    return new Promise((resolve, reject) => {
        send(data, function (err, result) {
            if (err)
                reject(err);
            else if (result.error)
                reject(result.error);
            else
                resolve(result.result);
        });
    });
}
async function isERC1271(account, provider) {
    const bytecode = await getCode(account.address, provider).catch(() => null);
    return Boolean(bytecode && bytecode !== '0x' && bytecode !== '0x0' && bytecode !== '0x00');
}
exports.isERC1271 = isERC1271;
function normalizeAccountId(account) {
    account.address = account.address.toLowerCase();
    return account;
}
exports.normalizeAccountId = normalizeAccountId;
function utf8toHex(message) {
    const bytes = uint8arrays.fromString(message);
    const hex = uint8arrays.toString(bytes, 'base16');
    return '0x' + hex;
}
async function createEthLink(did, account, provider, opts = {}) {
    const { message, timestamp } = util_1.getConsentMessage(did, !opts.skipTimestamp);
    const hexMessage = utf8toHex(message);
    const payload = util_1.encodeRpcMessage('personal_sign', [hexMessage, account.address]);
    const signature = await safeSend(payload, provider);
    const proof = {
        version: 2,
        type: ADDRESS_TYPES.ethereumEOA,
        message,
        signature,
        account: account.toString(),
    };
    if (!opts.skipTimestamp)
        proof.timestamp = timestamp;
    return proof;
}
async function validateChainId(account, provider) {
    const payload = util_1.encodeRpcMessage('eth_chainId', []);
    const chainIdHex = await safeSend(payload, provider);
    const chainId = parseInt(chainIdHex, 16);
    if (chainId !== parseInt(account.chainId.reference)) {
        throw new Error(`ChainId in provider (${chainId}) is different from AccountID (${account.chainId.reference})`);
    }
}
async function createErc1271Link(did, account, provider, opts) {
    const ethLinkAccount = (opts === null || opts === void 0 ? void 0 : opts.eoaSignAccount) || account;
    const res = await createEthLink(did, ethLinkAccount, provider, opts);
    await validateChainId(account, provider);
    return Object.assign(res, {
        type: ADDRESS_TYPES.erc1271,
        account: account.toString(),
    });
}
async function createLink(did, account, provider, opts) {
    account = normalizeAccountId(account);
    if (await isERC1271(account, provider)) {
        return createErc1271Link(did, account, provider, opts);
    }
    else {
        return createEthLink(did, account, provider, opts);
    }
}
exports.createLink = createLink;
async function authenticate(message, account, provider) {
    if (account)
        account = normalizeAccountId(account);
    if (provider.isAuthereum)
        return provider.signMessageWithSigningKey(message);
    const hexMessage = utf8toHex(message);
    const payload = util_1.encodeRpcMessage('personal_sign', [hexMessage, account.address]);
    const signature = await safeSend(payload, provider);
    const signatureBytes = uint8arrays.fromString(signature.slice(2));
    const digest = sha256.hash(signatureBytes);
    return `0x${uint8arrays.toString(digest, 'base16')}`;
}
exports.authenticate = authenticate;
//# sourceMappingURL=ethereum.js.map