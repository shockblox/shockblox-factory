function t(){return(t=Object.assign||function(t){for(var e=1;e<arguments.length;e++){var r=arguments[e];for(var n in r)Object.prototype.hasOwnProperty.call(r,n)&&(t[n]=r[n])}return t}).apply(this,arguments)}function e(){const t=new Map;return async(e,r)=>{var n;if(e.params&&"true"===e.params["no-cache"])return await r();const a=t.get(e.didUrl);if(void 0!==a)return a;const i=await r();return"notFound"!==(null==(n=i.didResolutionMetadata)?void 0:n.error)&&t.set(e.didUrl,i),i}}function r(t,e){return e()}const n=new RegExp("^did:([a-zA-Z0-9_]+):([a-zA-Z0-9_.%-]+(:[a-zA-Z0-9_.%-]+)*)((;[a-zA-Z0-9_.:%-]+=[a-zA-Z0-9_.:%-]*)*)(/[^#?]*)?([?][^#]*)?(#.*)?$");function a(t){if(""===t||!t)return null;const e=t.match(n);if(e){const r={did:`did:${e[1]}:${e[2]}`,method:e[1],id:e[2],didUrl:t};if(e[4]){const t=e[4].slice(1).split(";");r.params={};for(const e of t){const t=e.split("=");r.params[t[0]]=t[1]}}return e[6]&&(r.path=e[6]),e[7]&&(r.query=e[7].slice(1)),e[8]&&(r.fragment=e[8].slice(1)),r}return null}const i={didResolutionMetadata:{},didDocument:null,didDocumentMetadata:{}};function o(e){return async(r,n,a)=>{try{const o=await e(r,n,a);return t({},i,{didResolutionMetadata:{contentType:"application/did+ld+json"},didDocument:o})}catch(e){return t({},i,{didResolutionMetadata:{error:"notFound",message:e.toString()}})}}}class s{constructor(t={},n={}){this.registry=t,this.cache=!0===n.cache?e():n.cache||r,n.legacyResolvers&&Object.keys(n.legacyResolvers).map(t=>{this.registry[t]||(this.registry[t]=o(n.legacyResolvers[t]))})}async resolve(e,r={}){const n=a(e);if(null===n)return t({},i,{didResolutionMetadata:{error:"invalidDid"}});const o=this.registry[n.method];return o?this.cache(n,()=>o(n.did,n,this,r)):t({},i,{didResolutionMetadata:{error:"unsupportedDidMethod"}})}}export{s as Resolver,e as inMemoryCache,r as noCache,a as parse,o as wrapLegacyResolver};
//# sourceMappingURL=resolver.modern.js.map
