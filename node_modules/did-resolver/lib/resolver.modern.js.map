{"version":3,"file":"resolver.modern.js","sources":["../src/resolver.ts"],"sourcesContent":["// Copyright 2018 Consensys AG\n\n// Licensed under the Apache License, Version 2.0(the \"License\");\n// you may not use this file except in compliance with the License.\n// You may obtain a copy of the License at\n\n// http://www.apache.org/licenses/LICENSE-2.0\n\n// Unless required by applicable law or agreed to in writing, software\n// distributed under the License is distributed on an \"AS IS\" BASIS,\n//   WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n// See the License for the specific language governing permissions and\n// limitations under the License.\n\n// eslint-disable-next-line @typescript-eslint/no-explicit-any\ntype Extensible = Record<string, any>\n\nexport interface DIDResolutionResult {\n  didResolutionMetadata: DIDResolutionMetadata\n  didDocument: DIDDocument | null\n  didDocumentMetadata: DIDDocumentMetadata\n}\n\nexport interface DIDResolutionOptions extends Extensible {\n  accept?: string\n}\n\nexport interface DIDResolutionMetadata extends Extensible {\n  contentType?: string\n  error?:\n    | 'invalidDid'\n    | 'notFound'\n    | 'representationNotSupported'\n    | 'unsupportedDidMethod'\n    | string\n}\n\nexport interface DIDDocumentMetadata extends Extensible {\n  created?: string\n  updated?: string\n  deactivated?: boolean\n  versionId?: string\n  nextUpdate?: string\n  nextVersionId?: string\n  equivalentId?: string\n  canonicalId?: string\n}\n\nexport interface DIDDocument {\n  '@context'?: 'https://www.w3.org/ns/did/v1' | string | string[]\n  id: string\n  alsoKnownAs?: string[]\n  controller?: string | string[]\n  verificationMethod?: VerificationMethod[]\n  authentication?: (string | VerificationMethod)[]\n  assertionMethod?: (string | VerificationMethod)[]\n  keyAgreement?: (string | VerificationMethod)[]\n  capabilityInvocation?: (string | VerificationMethod)[]\n  capabilityDelegation?: (string | VerificationMethod)[]\n  service?: ServiceEndpoint[]\n  /**\n   * @deprecated\n   */\n  publicKey?: VerificationMethod[]\n}\n\nexport interface ServiceEndpoint {\n  id: string\n  type: string\n  serviceEndpoint: string\n  description?: string\n}\n\ninterface JsonWebKey extends Extensible {\n  alg?: string\n  crv?: string\n  e?: string\n  ext?: boolean\n  key_ops?: string[]\n  kid?: string\n  kty: string\n  n?: string\n  use?: string\n  x?: string\n  y?: string\n}\n\nexport interface VerificationMethod {\n  id: string\n  type: string\n  controller: string\n  publicKeyBase58?: string\n  publicKeyJwk?: JsonWebKey\n  publicKeyHex?: string\n  blockchainAccountId?: string\n  ethereumAddress?: string\n}\n\nexport interface Params {\n  [index: string]: string\n}\n\nexport interface ParsedDID {\n  did: string\n  didUrl: string\n  method: string\n  id: string\n  path?: string\n  fragment?: string\n  query?: string\n  params?: Params\n}\n\nexport type DIDResolver = (\n  did: string,\n  parsed: ParsedDID,\n  resolver: Resolver,\n  options: DIDResolutionOptions\n) => Promise<DIDResolutionResult>\nexport type WrappedResolver = () => Promise<DIDResolutionResult>\nexport type DIDCache = (\n  parsed: ParsedDID,\n  resolve: WrappedResolver\n) => Promise<DIDResolutionResult>\nexport type LegacyDIDResolver = (\n  did: string,\n  parsed: ParsedDID,\n  resolver: Resolver\n) => Promise<DIDDocument>\n\nexport interface ResolverRegistry {\n  [index: string]: DIDResolver\n}\n\nexport interface LegacyResolverRegistry {\n  [index: string]: LegacyDIDResolver\n}\n\nexport interface ResolverOptions {\n  cache?: DIDCache | boolean | undefined\n  legacyResolvers?: LegacyResolverRegistry\n}\n\nexport function inMemoryCache(): DIDCache {\n  const cache: Map<string, DIDResolutionResult> = new Map()\n  return async (parsed: ParsedDID, resolve) => {\n    if (parsed.params && parsed.params['no-cache'] === 'true')\n      return await resolve()\n\n    const cached = cache.get(parsed.didUrl)\n    if (cached !== undefined) return cached\n    const result = await resolve()\n    if (result.didResolutionMetadata?.error !== 'notFound') {\n      cache.set(parsed.didUrl, result)\n    }\n    return result\n  }\n}\n\nexport function noCache(\n  parsed: ParsedDID,\n  resolve: WrappedResolver\n): Promise<DIDResolutionResult> {\n  return resolve()\n}\n\nconst ID_CHAR = '[a-zA-Z0-9_.%-]'\nconst METHOD = '([a-zA-Z0-9_]+)'\nconst METHOD_ID = `(${ID_CHAR}+(:${ID_CHAR}+)*)`\nconst PARAM_CHAR = '[a-zA-Z0-9_.:%-]'\nconst PARAM = `;${PARAM_CHAR}+=${PARAM_CHAR}*`\nconst PARAMS = `((${PARAM})*)`\nconst PATH = `(\\/[^#?]*)?`\nconst QUERY = `([?][^#]*)?`\nconst FRAGMENT = `(\\#.*)?`\nconst DID_MATCHER = new RegExp(\n  `^did:${METHOD}:${METHOD_ID}${PARAMS}${PATH}${QUERY}${FRAGMENT}$`\n)\nexport function parse(didUrl: string): ParsedDID | null {\n  if (didUrl === '' || !didUrl) return null\n  const sections = didUrl.match(DID_MATCHER)\n  if (sections) {\n    const parts: ParsedDID = {\n      did: `did:${sections[1]}:${sections[2]}`,\n      method: sections[1],\n      id: sections[2],\n      didUrl\n    }\n    if (sections[4]) {\n      const params = sections[4].slice(1).split(';')\n      parts.params = {}\n      for (const p of params) {\n        const kv = p.split('=')\n        parts.params[kv[0]] = kv[1]\n      }\n    }\n    if (sections[6]) parts.path = sections[6]\n    if (sections[7]) parts.query = sections[7].slice(1)\n    if (sections[8]) parts.fragment = sections[8].slice(1)\n    return parts\n  }\n  return null\n}\n\nconst EMPTY_RESULT: DIDResolutionResult = {\n  didResolutionMetadata: {},\n  didDocument: null,\n  didDocumentMetadata: {}\n}\n\nexport function wrapLegacyResolver(resolve: LegacyDIDResolver): DIDResolver {\n  return async (did, parsed, resolver) => {\n    try {\n      const doc = await resolve(did, parsed, resolver)\n      return {\n        ...EMPTY_RESULT,\n        didResolutionMetadata: { contentType: 'application/did+ld+json' },\n        didDocument: doc\n      }\n    } catch (e) {\n      return {\n        ...EMPTY_RESULT,\n        didResolutionMetadata: {\n          error: 'notFound',\n          message: e.toString() // This is not in spec, nut may be helpful\n        }\n      }\n    }\n  }\n}\n\nexport type Resolvable = {\n  resolve: (\n    didUrl: string,\n    options?: DIDResolutionOptions\n  ) => Promise<DIDResolutionResult>\n}\n\nexport class Resolver implements Resolvable {\n  private registry: ResolverRegistry\n  private cache: DIDCache\n\n  constructor(registry: ResolverRegistry = {}, options: ResolverOptions = {}) {\n    this.registry = registry\n    this.cache =\n      options.cache === true ? inMemoryCache() : options.cache || noCache\n    if (options.legacyResolvers) {\n      Object.keys(options.legacyResolvers).map((methodName) => {\n        if (!this.registry[methodName]) {\n          this.registry[methodName] = wrapLegacyResolver(\n            // eslint-disable-next-line @typescript-eslint/no-non-null-assertion\n            options.legacyResolvers![methodName]\n          )\n        }\n      })\n    }\n  }\n\n  async resolve(\n    didUrl: string,\n    options: DIDResolutionOptions = {}\n  ): Promise<DIDResolutionResult> {\n    const parsed = parse(didUrl)\n    if (parsed === null) {\n      return {\n        ...EMPTY_RESULT,\n        didResolutionMetadata: { error: 'invalidDid' }\n      }\n    }\n    const resolver = this.registry[parsed.method]\n    if (!resolver) {\n      return {\n        ...EMPTY_RESULT,\n        didResolutionMetadata: { error: 'unsupportedDidMethod' }\n      }\n    }\n    return this.cache(parsed, () => resolver(parsed.did, parsed, this, options))\n  }\n}\n"],"names":["inMemoryCache","cache","Map","parsed","resolve","params","cached","get","didUrl","undefined","result","didResolutionMetadata","error","set","noCache","DID_MATCHER","RegExp","parse","sections","match","parts","did","method","id","slice","split","p","kv","path","query","fragment","EMPTY_RESULT","didDocument","didDocumentMetadata","wrapLegacyResolver","resolver","doc","contentType","e","message","toString","Resolver","constructor","registry","options","this","legacyResolvers","Object","keys","map","methodName","[object Object]"],"mappings":"wNA+IgBA,IACd,MAAMC,EAA0C,IAAIC,IACpD,aAAcC,EAAmBC,WAC/B,GAAID,EAAOE,QAAwC,SAA9BF,EAAOE,OAAO,YACjC,aAAaD,IAEf,MAAME,EAASL,EAAMM,IAAIJ,EAAOK,QAChC,QAAeC,IAAXH,EAAsB,OAAOA,EACjC,MAAMI,QAAeN,IAIrB,MAH4C,uBAAxCM,EAAOC,gCAAuBC,QAChCX,EAAMY,IAAIV,EAAOK,OAAQE,GAEpBA,YAIKI,EACdX,EACAC,GAEA,OAAOA,IAGT,MASMW,EAAc,IAAIC,oJAGRC,EAAMT,GACpB,GAAe,KAAXA,IAAkBA,EAAQ,YAC9B,MAAMU,EAAWV,EAAOW,MAAMJ,GAC9B,GAAIG,EAAU,CACZ,MAAME,EAAmB,CACvBC,WAAYH,EAAS,MAAMA,EAAS,KACpCI,OAAQJ,EAAS,GACjBK,GAAIL,EAAS,GACbV,OAAAA,GAEF,GAAIU,EAAS,GAAI,CACf,MAAMb,EAASa,EAAS,GAAGM,MAAM,GAAGC,MAAM,KAC1CL,EAAMf,OAAS,GACf,IAAK,MAAMqB,KAAKrB,EAAQ,CACtB,MAAMsB,EAAKD,EAAED,MAAM,KACnBL,EAAMf,OAAOsB,EAAG,IAAMA,EAAG,IAM7B,OAHIT,EAAS,KAAIE,EAAMQ,KAAOV,EAAS,IACnCA,EAAS,KAAIE,EAAMS,MAAQX,EAAS,GAAGM,MAAM,IAC7CN,EAAS,KAAIE,EAAMU,SAAWZ,EAAS,GAAGM,MAAM,IAC7CJ,EAET,YAGF,MAAMW,EAAoC,CACxCpB,sBAAuB,GACvBqB,YAAa,KACbC,oBAAqB,aAGPC,EAAmB9B,GACjC,aAAciB,EAAKlB,EAAQgC,KACzB,IACE,MAAMC,QAAYhC,EAAQiB,EAAKlB,EAAQgC,GACvC,YACKJ,GACHpB,sBAAuB,CAAE0B,YAAa,2BACtCL,YAAaI,IAEf,MAAOE,GACP,YACKP,GACHpB,sBAAuB,CACrBC,MAAO,WACP2B,QAASD,EAAEE,sBAcRC,EAIXC,YAAYC,EAA6B,GAAIC,EAA2B,IACtEC,KAAKF,SAAWA,EAChBE,KAAK5C,OACe,IAAlB2C,EAAQ3C,MAAiBD,IAAkB4C,EAAQ3C,OAASa,EAC1D8B,EAAQE,iBACVC,OAAOC,KAAKJ,EAAQE,iBAAiBG,IAAKC,IACnCL,KAAKF,SAASO,KACjBL,KAAKF,SAASO,GAAchB,EAE1BU,EAAQE,gBAAiBI,OAOtBC,cACX3C,EACAoC,EAAgC,IAEhC,MAAMzC,EAASc,EAAMT,GACrB,GAAe,OAAXL,EACF,YACK4B,GACHpB,sBAAuB,CAAEC,MAAO,gBAGpC,MAAMuB,EAAWU,KAAKF,SAASxC,EAAOmB,QACtC,OAAKa,OAMOlC,MAAME,EAAQ,IAAMgC,EAAShC,EAAOkB,IAAKlB,EAAQ0C,KAAMD,SAJ5Db,GACHpB,sBAAuB,CAAEC,MAAO"}